#' Create cross-validation training data sets.
#'
#' This function creates a list of training datasets each of which has
#' certain entries of `remove_cols` replaced by `NA` according to the
#' type of cross-validation chosen. If `type = "LOO"` one entry of each
#' training dataset is replaced by `NA`, if `type = "SLOO"` one entry and
#' the entries of the neighbours of the area it corresponds to are replaced
#' by `NA`.
#'
#' @param sf A simple features data frame.
#' @param remove_cols A vector of named columns which are to have entries
#' replaced by `NA` in the training data sets. Defaults to
#' `c("y")`.
#' @param type One of `"LOO"` or `"SLOO"`.
#' @return A list of `nrow(sf)` training set lists.
#' Each training set list contains:
#' * `data` The training data set with left-out entries.
#' * `held_out` The indices of all held-out regions.
#' * `predict_on` The indices of regions to be predicted upon.
#' @examples
#' create_folds(mw, remove_cols = c("y", "est"))
#' @export
create_folds <- function(sf, remove_cols = c("y"), type = "LOO"){
  n <- nrow(sf)
  training_sets <- vector(mode = "list", length = n)
  if(type == "SLOO"){
    nb <- neighbours(sf)
    for(i in 1:nrow(sf)) {
      sf_new <- sf
      i_neighbours <- nb[[i]]
      held_out <- c(i, i_neighbours)
      sf_new[c(i, i_neighbours), remove_cols] <- NA
      training_sets[[i]] <- list(data = sf_new, held_out = held_out, predict_on = i)
    }
  }
  if(type == "LOO"){
    for(i in 1:nrow(sf)){
      sf_new <- sf
      sf_new[i, remove_cols] <- NA
      training_sets[[i]] <- list(data = sf_new, held_out = i, predict_on = i)
    }
  }
  return(training_sets)
}

#' Cross-validation using [`create_folds`].
#'
#' This function fits an model specified via `fn` upon each of
#' the training datasets generated by `create_folds` and then evaluates
#' their prediction according to either `eval_stan_model` or 
#' `eval_inla_model`.
#' 
#' @param sf A simple features data frame.
#' @param fn A model fitting function.
#' @param ... Additional arguments to `fn`.
#' @param S The number of Monte Carlo samples to draw from the `R-INLA`
#' approximate posterior distribution over the latent field.
#' @inheritParams create_folds
#' @return A vector of log density scores (one entry for training data set
#' produced by [`create_folds`].
#' @examples
#' cv(mw, type = "LOO", fn = m1_inla)
#' @export
cv <- function(sf, type = "LOO", fn, ..., S = 5000){
  n <- nrow(sf)
  training_sets <- create_folds(sf, remove_cols = c("y", "est"), type = type)
  fits <- lapply(training_sets, FUN = function(set) fn(set$data, ...))

  tsfs <- training_sets
  for(i in 1:nrow(sf)) tsfs[[i]]$fit <- fits[[i]]
  
  if(class(fits[[1]]) == "stanfit"){
    scores <- lapply(tsfs, FUN = function(tsf) 
      eval_stan_model(sf, tsf$fit, tsf$predict_on))
  }
  
  if(class(fits[[1]]) == "inla"){
    scores <- lapply(tsfs, FUN = function(tsf) 
      eval_inla_model(sf, tsf$fit, tsf$predict_on, S = S))
  }

  message(paste0("Completed ", type, "-CV"))
  
  return(list(tsfs = tsfs, scores = unlist(scores)))
}

#' Compute DIC, WAIC and CPO for either `stan` or `R-INLA` models.
#'
#' Wrapper function for `stan_info_criteria` and `inla_info_criteria`.
#' 
#' @param fit A fitted `stan` or `R-INLA` model.
#' @export
info_criteria <- function(fit){
  if(class(fit) == "stanfit"){
    ic <- stan_info_criteria(fit)
  }
  
  if(class(fit) == "inla"){
    ic <- inla_info_criteria(fit)
  }
  return(ic)
}

#' Perform lengthscale hyperparameter tuning for kernel SAE methods.
#'
#' @inheritParams m1_inla
#' @inheritParams cv
#' @param grid A sequence of length-scale parameters.
tune_lengthscale <- function(sf, fn = m5_inla, grid = seq(0.05, 0.5, by = 0.025), ...){
  waic <- lapply(grid, function(k) fn(sf, kernel = matern, l = k, ...)$waic$waic)
  return(cbind(grid, waic))
}